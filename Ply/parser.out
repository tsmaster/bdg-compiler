Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> toplevelgroup
Rule 1     toplevelgroup -> funcdecl toplevelgroup
Rule 2     toplevelgroup -> funcdef toplevelgroup
Rule 3     toplevelgroup -> globalvardecl toplevelgroup
Rule 4     toplevelgroup -> empty
Rule 5     funcdecl -> type IDENTIFIER LPAREN argdecllist RPAREN SEMICOLON
Rule 6     funcdef -> type IDENTIFIER LPAREN argdecllist RPAREN LBRACE statementlist RBRACE
Rule 7     type -> INT
Rule 8     type -> FLOAT
Rule 9     type -> STRING
Rule 10    type -> VOID
Rule 11    type -> IDENTIFIER
Rule 12    argdecllist -> empty
Rule 13    argdecllist -> argdecl
Rule 14    argdecllist -> argdecl COMMA argdecllist
Rule 15    argdecl -> type IDENTIFIER
Rule 16    empty -> <empty>
Rule 17    arglist -> empty
Rule 18    arglist -> expression
Rule 19    arglist -> expression COMMA arglist
Rule 20    globalvardecl -> type IDENTIFIER SEMICOLON
Rule 21    statementlist -> empty
Rule 22    statementlist -> statement statementlist
Rule 23    statement -> expression SEMICOLON
Rule 24    statement -> ifelse
Rule 25    statement -> RETURN expression SEMICOLON
Rule 26    statement -> LOOP LBRACE statementlist RBRACE
Rule 27    statement -> BREAK SEMICOLON
Rule 28    statement -> WHILE LPAREN expression RPAREN LBRACE statementlist RBRACE
Rule 29    statement -> IDENTIFIER ASSIGN expression SEMICOLON
Rule 30    expression -> IDENTIFIER LPAREN arglist RPAREN
Rule 31    expression -> expression compare expression
Rule 32    expression -> expression arithop expression
Rule 33    expression -> IDENTIFIER
Rule 34    expression -> MINUS expression
Rule 35    expression -> NUMBER
Rule 36    compare -> ISEQUAL
Rule 37    compare -> LESSTHAN
Rule 38    compare -> MORETHAN
Rule 39    arithop -> PLUS
Rule 40    arithop -> MINUS
Rule 41    arithop -> TIMES
Rule 42    arithop -> DIVIDE
Rule 43    elifgroup -> empty
Rule 44    elifgroup -> ELIF LPAREN expression RPAREN LBRACE statementlist RBRACE elifgroup
Rule 45    optelse -> empty
Rule 46    optelse -> ELSE LBRACE statementlist RBRACE
Rule 47    ifelse -> IF LPAREN expression RPAREN LBRACE statementlist RBRACE elifgroup optelse

Terminals, with rules where they appear

ASSIGN               : 29
BREAK                : 27
COMMA                : 14 19
DIVIDE               : 42
ELIF                 : 44
ELSE                 : 46
FLOAT                : 8
IDENTIFIER           : 5 6 11 15 20 29 30 33
IF                   : 47
INT                  : 7
ISEQUAL              : 36
LBRACE               : 6 26 28 44 46 47
LESSTHAN             : 37
LOOP                 : 26
LPAREN               : 5 6 28 30 44 47
MINUS                : 34 40
MORETHAN             : 38
NUMBER               : 35
PLUS                 : 39
RBRACE               : 6 26 28 44 46 47
RETURN               : 25
RPAREN               : 5 6 28 30 44 47
SEMICOLON            : 5 20 23 25 27 29
STRING               : 9
TIMES                : 41
VOID                 : 10
WHILE                : 28
error                : 

Nonterminals, with rules where they appear

argdecl              : 13 14
argdecllist          : 5 6 14
arglist              : 19 30
arithop              : 32
compare              : 31
elifgroup            : 44 47
empty                : 4 12 17 21 43 45
expression           : 18 19 23 25 28 29 31 31 32 32 34 44 47
funcdecl             : 1
funcdef              : 2
globalvardecl        : 3
ifelse               : 24
optelse              : 47
statement            : 22
statementlist        : 6 22 26 28 44 46 47
toplevelgroup        : 1 2 3 0
type                 : 5 6 15 20

Parsing method: LALR

state 0

    (0) S' -> . toplevelgroup
    (1) toplevelgroup -> . funcdecl toplevelgroup
    (2) toplevelgroup -> . funcdef toplevelgroup
    (3) toplevelgroup -> . globalvardecl toplevelgroup
    (4) toplevelgroup -> . empty
    (5) funcdecl -> . type IDENTIFIER LPAREN argdecllist RPAREN SEMICOLON
    (6) funcdef -> . type IDENTIFIER LPAREN argdecllist RPAREN LBRACE statementlist RBRACE
    (20) globalvardecl -> . type IDENTIFIER SEMICOLON
    (16) empty -> .
    (7) type -> . INT
    (8) type -> . FLOAT
    (9) type -> . STRING
    (10) type -> . VOID
    (11) type -> . IDENTIFIER

    $end            reduce using rule 16 (empty -> .)
    INT             shift and go to state 1
    FLOAT           shift and go to state 4
    STRING          shift and go to state 11
    VOID            shift and go to state 5
    IDENTIFIER      shift and go to state 7

    funcdecl                       shift and go to state 2
    toplevelgroup                  shift and go to state 3
    funcdef                        shift and go to state 6
    type                           shift and go to state 8
    globalvardecl                  shift and go to state 9
    empty                          shift and go to state 10

state 1

    (7) type -> INT .

    IDENTIFIER      reduce using rule 7 (type -> INT .)


state 2

    (1) toplevelgroup -> funcdecl . toplevelgroup
    (1) toplevelgroup -> . funcdecl toplevelgroup
    (2) toplevelgroup -> . funcdef toplevelgroup
    (3) toplevelgroup -> . globalvardecl toplevelgroup
    (4) toplevelgroup -> . empty
    (5) funcdecl -> . type IDENTIFIER LPAREN argdecllist RPAREN SEMICOLON
    (6) funcdef -> . type IDENTIFIER LPAREN argdecllist RPAREN LBRACE statementlist RBRACE
    (20) globalvardecl -> . type IDENTIFIER SEMICOLON
    (16) empty -> .
    (7) type -> . INT
    (8) type -> . FLOAT
    (9) type -> . STRING
    (10) type -> . VOID
    (11) type -> . IDENTIFIER

    $end            reduce using rule 16 (empty -> .)
    INT             shift and go to state 1
    FLOAT           shift and go to state 4
    STRING          shift and go to state 11
    VOID            shift and go to state 5
    IDENTIFIER      shift and go to state 7

    funcdecl                       shift and go to state 2
    toplevelgroup                  shift and go to state 12
    funcdef                        shift and go to state 6
    type                           shift and go to state 8
    globalvardecl                  shift and go to state 9
    empty                          shift and go to state 10

state 3

    (0) S' -> toplevelgroup .



state 4

    (8) type -> FLOAT .

    IDENTIFIER      reduce using rule 8 (type -> FLOAT .)


state 5

    (10) type -> VOID .

    IDENTIFIER      reduce using rule 10 (type -> VOID .)


state 6

    (2) toplevelgroup -> funcdef . toplevelgroup
    (1) toplevelgroup -> . funcdecl toplevelgroup
    (2) toplevelgroup -> . funcdef toplevelgroup
    (3) toplevelgroup -> . globalvardecl toplevelgroup
    (4) toplevelgroup -> . empty
    (5) funcdecl -> . type IDENTIFIER LPAREN argdecllist RPAREN SEMICOLON
    (6) funcdef -> . type IDENTIFIER LPAREN argdecllist RPAREN LBRACE statementlist RBRACE
    (20) globalvardecl -> . type IDENTIFIER SEMICOLON
    (16) empty -> .
    (7) type -> . INT
    (8) type -> . FLOAT
    (9) type -> . STRING
    (10) type -> . VOID
    (11) type -> . IDENTIFIER

    $end            reduce using rule 16 (empty -> .)
    INT             shift and go to state 1
    FLOAT           shift and go to state 4
    STRING          shift and go to state 11
    VOID            shift and go to state 5
    IDENTIFIER      shift and go to state 7

    funcdecl                       shift and go to state 2
    toplevelgroup                  shift and go to state 13
    funcdef                        shift and go to state 6
    type                           shift and go to state 8
    globalvardecl                  shift and go to state 9
    empty                          shift and go to state 10

state 7

    (11) type -> IDENTIFIER .

    IDENTIFIER      reduce using rule 11 (type -> IDENTIFIER .)


state 8

    (5) funcdecl -> type . IDENTIFIER LPAREN argdecllist RPAREN SEMICOLON
    (6) funcdef -> type . IDENTIFIER LPAREN argdecllist RPAREN LBRACE statementlist RBRACE
    (20) globalvardecl -> type . IDENTIFIER SEMICOLON

    IDENTIFIER      shift and go to state 14


state 9

    (3) toplevelgroup -> globalvardecl . toplevelgroup
    (1) toplevelgroup -> . funcdecl toplevelgroup
    (2) toplevelgroup -> . funcdef toplevelgroup
    (3) toplevelgroup -> . globalvardecl toplevelgroup
    (4) toplevelgroup -> . empty
    (5) funcdecl -> . type IDENTIFIER LPAREN argdecllist RPAREN SEMICOLON
    (6) funcdef -> . type IDENTIFIER LPAREN argdecllist RPAREN LBRACE statementlist RBRACE
    (20) globalvardecl -> . type IDENTIFIER SEMICOLON
    (16) empty -> .
    (7) type -> . INT
    (8) type -> . FLOAT
    (9) type -> . STRING
    (10) type -> . VOID
    (11) type -> . IDENTIFIER

    $end            reduce using rule 16 (empty -> .)
    INT             shift and go to state 1
    FLOAT           shift and go to state 4
    STRING          shift and go to state 11
    VOID            shift and go to state 5
    IDENTIFIER      shift and go to state 7

    funcdecl                       shift and go to state 2
    toplevelgroup                  shift and go to state 15
    funcdef                        shift and go to state 6
    type                           shift and go to state 8
    globalvardecl                  shift and go to state 9
    empty                          shift and go to state 10

state 10

    (4) toplevelgroup -> empty .

    $end            reduce using rule 4 (toplevelgroup -> empty .)


state 11

    (9) type -> STRING .

    IDENTIFIER      reduce using rule 9 (type -> STRING .)


state 12

    (1) toplevelgroup -> funcdecl toplevelgroup .

    $end            reduce using rule 1 (toplevelgroup -> funcdecl toplevelgroup .)


state 13

    (2) toplevelgroup -> funcdef toplevelgroup .

    $end            reduce using rule 2 (toplevelgroup -> funcdef toplevelgroup .)


state 14

    (5) funcdecl -> type IDENTIFIER . LPAREN argdecllist RPAREN SEMICOLON
    (6) funcdef -> type IDENTIFIER . LPAREN argdecllist RPAREN LBRACE statementlist RBRACE
    (20) globalvardecl -> type IDENTIFIER . SEMICOLON

    LPAREN          shift and go to state 17
    SEMICOLON       shift and go to state 16


state 15

    (3) toplevelgroup -> globalvardecl toplevelgroup .

    $end            reduce using rule 3 (toplevelgroup -> globalvardecl toplevelgroup .)


state 16

    (20) globalvardecl -> type IDENTIFIER SEMICOLON .

    INT             reduce using rule 20 (globalvardecl -> type IDENTIFIER SEMICOLON .)
    FLOAT           reduce using rule 20 (globalvardecl -> type IDENTIFIER SEMICOLON .)
    STRING          reduce using rule 20 (globalvardecl -> type IDENTIFIER SEMICOLON .)
    VOID            reduce using rule 20 (globalvardecl -> type IDENTIFIER SEMICOLON .)
    IDENTIFIER      reduce using rule 20 (globalvardecl -> type IDENTIFIER SEMICOLON .)
    $end            reduce using rule 20 (globalvardecl -> type IDENTIFIER SEMICOLON .)


state 17

    (5) funcdecl -> type IDENTIFIER LPAREN . argdecllist RPAREN SEMICOLON
    (6) funcdef -> type IDENTIFIER LPAREN . argdecllist RPAREN LBRACE statementlist RBRACE
    (12) argdecllist -> . empty
    (13) argdecllist -> . argdecl
    (14) argdecllist -> . argdecl COMMA argdecllist
    (16) empty -> .
    (15) argdecl -> . type IDENTIFIER
    (7) type -> . INT
    (8) type -> . FLOAT
    (9) type -> . STRING
    (10) type -> . VOID
    (11) type -> . IDENTIFIER

    RPAREN          reduce using rule 16 (empty -> .)
    INT             shift and go to state 1
    FLOAT           shift and go to state 4
    STRING          shift and go to state 11
    VOID            shift and go to state 5
    IDENTIFIER      shift and go to state 7

    argdecllist                    shift and go to state 18
    type                           shift and go to state 20
    empty                          shift and go to state 21
    argdecl                        shift and go to state 19

state 18

    (5) funcdecl -> type IDENTIFIER LPAREN argdecllist . RPAREN SEMICOLON
    (6) funcdef -> type IDENTIFIER LPAREN argdecllist . RPAREN LBRACE statementlist RBRACE

    RPAREN          shift and go to state 22


state 19

    (13) argdecllist -> argdecl .
    (14) argdecllist -> argdecl . COMMA argdecllist

    RPAREN          reduce using rule 13 (argdecllist -> argdecl .)
    COMMA           shift and go to state 23


state 20

    (15) argdecl -> type . IDENTIFIER

    IDENTIFIER      shift and go to state 24


state 21

    (12) argdecllist -> empty .

    RPAREN          reduce using rule 12 (argdecllist -> empty .)


state 22

    (5) funcdecl -> type IDENTIFIER LPAREN argdecllist RPAREN . SEMICOLON
    (6) funcdef -> type IDENTIFIER LPAREN argdecllist RPAREN . LBRACE statementlist RBRACE

    SEMICOLON       shift and go to state 25
    LBRACE          shift and go to state 26


state 23

    (14) argdecllist -> argdecl COMMA . argdecllist
    (12) argdecllist -> . empty
    (13) argdecllist -> . argdecl
    (14) argdecllist -> . argdecl COMMA argdecllist
    (16) empty -> .
    (15) argdecl -> . type IDENTIFIER
    (7) type -> . INT
    (8) type -> . FLOAT
    (9) type -> . STRING
    (10) type -> . VOID
    (11) type -> . IDENTIFIER

    RPAREN          reduce using rule 16 (empty -> .)
    INT             shift and go to state 1
    FLOAT           shift and go to state 4
    STRING          shift and go to state 11
    VOID            shift and go to state 5
    IDENTIFIER      shift and go to state 7

    argdecllist                    shift and go to state 27
    type                           shift and go to state 20
    empty                          shift and go to state 21
    argdecl                        shift and go to state 19

state 24

    (15) argdecl -> type IDENTIFIER .

    COMMA           reduce using rule 15 (argdecl -> type IDENTIFIER .)
    RPAREN          reduce using rule 15 (argdecl -> type IDENTIFIER .)


state 25

    (5) funcdecl -> type IDENTIFIER LPAREN argdecllist RPAREN SEMICOLON .

    INT             reduce using rule 5 (funcdecl -> type IDENTIFIER LPAREN argdecllist RPAREN SEMICOLON .)
    FLOAT           reduce using rule 5 (funcdecl -> type IDENTIFIER LPAREN argdecllist RPAREN SEMICOLON .)
    STRING          reduce using rule 5 (funcdecl -> type IDENTIFIER LPAREN argdecllist RPAREN SEMICOLON .)
    VOID            reduce using rule 5 (funcdecl -> type IDENTIFIER LPAREN argdecllist RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 5 (funcdecl -> type IDENTIFIER LPAREN argdecllist RPAREN SEMICOLON .)
    $end            reduce using rule 5 (funcdecl -> type IDENTIFIER LPAREN argdecllist RPAREN SEMICOLON .)


state 26

    (6) funcdef -> type IDENTIFIER LPAREN argdecllist RPAREN LBRACE . statementlist RBRACE
    (21) statementlist -> . empty
    (22) statementlist -> . statement statementlist
    (16) empty -> .
    (23) statement -> . expression SEMICOLON
    (24) statement -> . ifelse
    (25) statement -> . RETURN expression SEMICOLON
    (26) statement -> . LOOP LBRACE statementlist RBRACE
    (27) statement -> . BREAK SEMICOLON
    (28) statement -> . WHILE LPAREN expression RPAREN LBRACE statementlist RBRACE
    (29) statement -> . IDENTIFIER ASSIGN expression SEMICOLON
    (30) expression -> . IDENTIFIER LPAREN arglist RPAREN
    (31) expression -> . expression compare expression
    (32) expression -> . expression arithop expression
    (33) expression -> . IDENTIFIER
    (34) expression -> . MINUS expression
    (35) expression -> . NUMBER
    (47) ifelse -> . IF LPAREN expression RPAREN LBRACE statementlist RBRACE elifgroup optelse

    RBRACE          reduce using rule 16 (empty -> .)
    RETURN          shift and go to state 28
    LOOP            shift and go to state 40
    BREAK           shift and go to state 38
    WHILE           shift and go to state 31
    IDENTIFIER      shift and go to state 35
    MINUS           shift and go to state 32
    NUMBER          shift and go to state 29
    IF              shift and go to state 37

    expression                     shift and go to state 39
    statementlist                  shift and go to state 30
    ifelse                         shift and go to state 33
    statement                      shift and go to state 34
    empty                          shift and go to state 36

state 27

    (14) argdecllist -> argdecl COMMA argdecllist .

    RPAREN          reduce using rule 14 (argdecllist -> argdecl COMMA argdecllist .)


state 28

    (25) statement -> RETURN . expression SEMICOLON
    (30) expression -> . IDENTIFIER LPAREN arglist RPAREN
    (31) expression -> . expression compare expression
    (32) expression -> . expression arithop expression
    (33) expression -> . IDENTIFIER
    (34) expression -> . MINUS expression
    (35) expression -> . NUMBER

    IDENTIFIER      shift and go to state 41
    MINUS           shift and go to state 32
    NUMBER          shift and go to state 29

    expression                     shift and go to state 42

state 29

    (35) expression -> NUMBER .

    SEMICOLON       reduce using rule 35 (expression -> NUMBER .)
    ISEQUAL         reduce using rule 35 (expression -> NUMBER .)
    LESSTHAN        reduce using rule 35 (expression -> NUMBER .)
    MORETHAN        reduce using rule 35 (expression -> NUMBER .)
    PLUS            reduce using rule 35 (expression -> NUMBER .)
    MINUS           reduce using rule 35 (expression -> NUMBER .)
    TIMES           reduce using rule 35 (expression -> NUMBER .)
    DIVIDE          reduce using rule 35 (expression -> NUMBER .)
    RPAREN          reduce using rule 35 (expression -> NUMBER .)
    COMMA           reduce using rule 35 (expression -> NUMBER .)


state 30

    (6) funcdef -> type IDENTIFIER LPAREN argdecllist RPAREN LBRACE statementlist . RBRACE

    RBRACE          shift and go to state 43


state 31

    (28) statement -> WHILE . LPAREN expression RPAREN LBRACE statementlist RBRACE

    LPAREN          shift and go to state 44


state 32

    (34) expression -> MINUS . expression
    (30) expression -> . IDENTIFIER LPAREN arglist RPAREN
    (31) expression -> . expression compare expression
    (32) expression -> . expression arithop expression
    (33) expression -> . IDENTIFIER
    (34) expression -> . MINUS expression
    (35) expression -> . NUMBER

    IDENTIFIER      shift and go to state 41
    MINUS           shift and go to state 32
    NUMBER          shift and go to state 29

    expression                     shift and go to state 45

state 33

    (24) statement -> ifelse .

    RETURN          reduce using rule 24 (statement -> ifelse .)
    LOOP            reduce using rule 24 (statement -> ifelse .)
    BREAK           reduce using rule 24 (statement -> ifelse .)
    WHILE           reduce using rule 24 (statement -> ifelse .)
    IDENTIFIER      reduce using rule 24 (statement -> ifelse .)
    MINUS           reduce using rule 24 (statement -> ifelse .)
    NUMBER          reduce using rule 24 (statement -> ifelse .)
    IF              reduce using rule 24 (statement -> ifelse .)
    RBRACE          reduce using rule 24 (statement -> ifelse .)


state 34

    (22) statementlist -> statement . statementlist
    (21) statementlist -> . empty
    (22) statementlist -> . statement statementlist
    (16) empty -> .
    (23) statement -> . expression SEMICOLON
    (24) statement -> . ifelse
    (25) statement -> . RETURN expression SEMICOLON
    (26) statement -> . LOOP LBRACE statementlist RBRACE
    (27) statement -> . BREAK SEMICOLON
    (28) statement -> . WHILE LPAREN expression RPAREN LBRACE statementlist RBRACE
    (29) statement -> . IDENTIFIER ASSIGN expression SEMICOLON
    (30) expression -> . IDENTIFIER LPAREN arglist RPAREN
    (31) expression -> . expression compare expression
    (32) expression -> . expression arithop expression
    (33) expression -> . IDENTIFIER
    (34) expression -> . MINUS expression
    (35) expression -> . NUMBER
    (47) ifelse -> . IF LPAREN expression RPAREN LBRACE statementlist RBRACE elifgroup optelse

    RBRACE          reduce using rule 16 (empty -> .)
    RETURN          shift and go to state 28
    LOOP            shift and go to state 40
    BREAK           shift and go to state 38
    WHILE           shift and go to state 31
    IDENTIFIER      shift and go to state 35
    MINUS           shift and go to state 32
    NUMBER          shift and go to state 29
    IF              shift and go to state 37

    statementlist                  shift and go to state 46
    ifelse                         shift and go to state 33
    statement                      shift and go to state 34
    expression                     shift and go to state 39
    empty                          shift and go to state 36

state 35

    (29) statement -> IDENTIFIER . ASSIGN expression SEMICOLON
    (30) expression -> IDENTIFIER . LPAREN arglist RPAREN
    (33) expression -> IDENTIFIER .

    ASSIGN          shift and go to state 48
    LPAREN          shift and go to state 47
    SEMICOLON       reduce using rule 33 (expression -> IDENTIFIER .)
    ISEQUAL         reduce using rule 33 (expression -> IDENTIFIER .)
    LESSTHAN        reduce using rule 33 (expression -> IDENTIFIER .)
    MORETHAN        reduce using rule 33 (expression -> IDENTIFIER .)
    PLUS            reduce using rule 33 (expression -> IDENTIFIER .)
    MINUS           reduce using rule 33 (expression -> IDENTIFIER .)
    TIMES           reduce using rule 33 (expression -> IDENTIFIER .)
    DIVIDE          reduce using rule 33 (expression -> IDENTIFIER .)


state 36

    (21) statementlist -> empty .

    RBRACE          reduce using rule 21 (statementlist -> empty .)


state 37

    (47) ifelse -> IF . LPAREN expression RPAREN LBRACE statementlist RBRACE elifgroup optelse

    LPAREN          shift and go to state 49


state 38

    (27) statement -> BREAK . SEMICOLON

    SEMICOLON       shift and go to state 50


state 39

    (23) statement -> expression . SEMICOLON
    (31) expression -> expression . compare expression
    (32) expression -> expression . arithop expression
    (36) compare -> . ISEQUAL
    (37) compare -> . LESSTHAN
    (38) compare -> . MORETHAN
    (39) arithop -> . PLUS
    (40) arithop -> . MINUS
    (41) arithop -> . TIMES
    (42) arithop -> . DIVIDE

    SEMICOLON       shift and go to state 54
    ISEQUAL         shift and go to state 58
    LESSTHAN        shift and go to state 56
    MORETHAN        shift and go to state 59
    PLUS            shift and go to state 57
    MINUS           shift and go to state 60
    TIMES           shift and go to state 55
    DIVIDE          shift and go to state 53

    arithop                        shift and go to state 51
    compare                        shift and go to state 52

state 40

    (26) statement -> LOOP . LBRACE statementlist RBRACE

    LBRACE          shift and go to state 61


state 41

    (30) expression -> IDENTIFIER . LPAREN arglist RPAREN
    (33) expression -> IDENTIFIER .

    LPAREN          shift and go to state 47
    RPAREN          reduce using rule 33 (expression -> IDENTIFIER .)
    ISEQUAL         reduce using rule 33 (expression -> IDENTIFIER .)
    LESSTHAN        reduce using rule 33 (expression -> IDENTIFIER .)
    MORETHAN        reduce using rule 33 (expression -> IDENTIFIER .)
    PLUS            reduce using rule 33 (expression -> IDENTIFIER .)
    MINUS           reduce using rule 33 (expression -> IDENTIFIER .)
    TIMES           reduce using rule 33 (expression -> IDENTIFIER .)
    DIVIDE          reduce using rule 33 (expression -> IDENTIFIER .)
    SEMICOLON       reduce using rule 33 (expression -> IDENTIFIER .)
    COMMA           reduce using rule 33 (expression -> IDENTIFIER .)


state 42

    (25) statement -> RETURN expression . SEMICOLON
    (31) expression -> expression . compare expression
    (32) expression -> expression . arithop expression
    (36) compare -> . ISEQUAL
    (37) compare -> . LESSTHAN
    (38) compare -> . MORETHAN
    (39) arithop -> . PLUS
    (40) arithop -> . MINUS
    (41) arithop -> . TIMES
    (42) arithop -> . DIVIDE

    SEMICOLON       shift and go to state 62
    ISEQUAL         shift and go to state 58
    LESSTHAN        shift and go to state 56
    MORETHAN        shift and go to state 59
    PLUS            shift and go to state 57
    MINUS           shift and go to state 60
    TIMES           shift and go to state 55
    DIVIDE          shift and go to state 53

    arithop                        shift and go to state 51
    compare                        shift and go to state 52

state 43

    (6) funcdef -> type IDENTIFIER LPAREN argdecllist RPAREN LBRACE statementlist RBRACE .

    INT             reduce using rule 6 (funcdef -> type IDENTIFIER LPAREN argdecllist RPAREN LBRACE statementlist RBRACE .)
    FLOAT           reduce using rule 6 (funcdef -> type IDENTIFIER LPAREN argdecllist RPAREN LBRACE statementlist RBRACE .)
    STRING          reduce using rule 6 (funcdef -> type IDENTIFIER LPAREN argdecllist RPAREN LBRACE statementlist RBRACE .)
    VOID            reduce using rule 6 (funcdef -> type IDENTIFIER LPAREN argdecllist RPAREN LBRACE statementlist RBRACE .)
    IDENTIFIER      reduce using rule 6 (funcdef -> type IDENTIFIER LPAREN argdecllist RPAREN LBRACE statementlist RBRACE .)
    $end            reduce using rule 6 (funcdef -> type IDENTIFIER LPAREN argdecllist RPAREN LBRACE statementlist RBRACE .)


state 44

    (28) statement -> WHILE LPAREN . expression RPAREN LBRACE statementlist RBRACE
    (30) expression -> . IDENTIFIER LPAREN arglist RPAREN
    (31) expression -> . expression compare expression
    (32) expression -> . expression arithop expression
    (33) expression -> . IDENTIFIER
    (34) expression -> . MINUS expression
    (35) expression -> . NUMBER

    IDENTIFIER      shift and go to state 41
    MINUS           shift and go to state 32
    NUMBER          shift and go to state 29

    expression                     shift and go to state 63

state 45

    (34) expression -> MINUS expression .
    (31) expression -> expression . compare expression
    (32) expression -> expression . arithop expression
    (36) compare -> . ISEQUAL
    (37) compare -> . LESSTHAN
    (38) compare -> . MORETHAN
    (39) arithop -> . PLUS
    (40) arithop -> . MINUS
    (41) arithop -> . TIMES
    (42) arithop -> . DIVIDE

  ! shift/reduce conflict for ISEQUAL resolved as shift
  ! shift/reduce conflict for LESSTHAN resolved as shift
  ! shift/reduce conflict for MORETHAN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
    SEMICOLON       reduce using rule 34 (expression -> MINUS expression .)
    RPAREN          reduce using rule 34 (expression -> MINUS expression .)
    COMMA           reduce using rule 34 (expression -> MINUS expression .)
    ISEQUAL         shift and go to state 58
    LESSTHAN        shift and go to state 56
    MORETHAN        shift and go to state 59
    PLUS            shift and go to state 57
    MINUS           shift and go to state 60
    TIMES           shift and go to state 55
    DIVIDE          shift and go to state 53

  ! ISEQUAL         [ reduce using rule 34 (expression -> MINUS expression .) ]
  ! LESSTHAN        [ reduce using rule 34 (expression -> MINUS expression .) ]
  ! MORETHAN        [ reduce using rule 34 (expression -> MINUS expression .) ]
  ! PLUS            [ reduce using rule 34 (expression -> MINUS expression .) ]
  ! MINUS           [ reduce using rule 34 (expression -> MINUS expression .) ]
  ! TIMES           [ reduce using rule 34 (expression -> MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 34 (expression -> MINUS expression .) ]

    arithop                        shift and go to state 51
    compare                        shift and go to state 52

state 46

    (22) statementlist -> statement statementlist .

    RBRACE          reduce using rule 22 (statementlist -> statement statementlist .)


state 47

    (30) expression -> IDENTIFIER LPAREN . arglist RPAREN
    (17) arglist -> . empty
    (18) arglist -> . expression
    (19) arglist -> . expression COMMA arglist
    (16) empty -> .
    (30) expression -> . IDENTIFIER LPAREN arglist RPAREN
    (31) expression -> . expression compare expression
    (32) expression -> . expression arithop expression
    (33) expression -> . IDENTIFIER
    (34) expression -> . MINUS expression
    (35) expression -> . NUMBER

    RPAREN          reduce using rule 16 (empty -> .)
    IDENTIFIER      shift and go to state 41
    MINUS           shift and go to state 32
    NUMBER          shift and go to state 29

    arglist                        shift and go to state 64
    expression                     shift and go to state 65
    empty                          shift and go to state 66

state 48

    (29) statement -> IDENTIFIER ASSIGN . expression SEMICOLON
    (30) expression -> . IDENTIFIER LPAREN arglist RPAREN
    (31) expression -> . expression compare expression
    (32) expression -> . expression arithop expression
    (33) expression -> . IDENTIFIER
    (34) expression -> . MINUS expression
    (35) expression -> . NUMBER

    IDENTIFIER      shift and go to state 41
    MINUS           shift and go to state 32
    NUMBER          shift and go to state 29

    expression                     shift and go to state 67

state 49

    (47) ifelse -> IF LPAREN . expression RPAREN LBRACE statementlist RBRACE elifgroup optelse
    (30) expression -> . IDENTIFIER LPAREN arglist RPAREN
    (31) expression -> . expression compare expression
    (32) expression -> . expression arithop expression
    (33) expression -> . IDENTIFIER
    (34) expression -> . MINUS expression
    (35) expression -> . NUMBER

    IDENTIFIER      shift and go to state 41
    MINUS           shift and go to state 32
    NUMBER          shift and go to state 29

    expression                     shift and go to state 68

state 50

    (27) statement -> BREAK SEMICOLON .

    RETURN          reduce using rule 27 (statement -> BREAK SEMICOLON .)
    LOOP            reduce using rule 27 (statement -> BREAK SEMICOLON .)
    BREAK           reduce using rule 27 (statement -> BREAK SEMICOLON .)
    WHILE           reduce using rule 27 (statement -> BREAK SEMICOLON .)
    IDENTIFIER      reduce using rule 27 (statement -> BREAK SEMICOLON .)
    MINUS           reduce using rule 27 (statement -> BREAK SEMICOLON .)
    NUMBER          reduce using rule 27 (statement -> BREAK SEMICOLON .)
    IF              reduce using rule 27 (statement -> BREAK SEMICOLON .)
    RBRACE          reduce using rule 27 (statement -> BREAK SEMICOLON .)


state 51

    (32) expression -> expression arithop . expression
    (30) expression -> . IDENTIFIER LPAREN arglist RPAREN
    (31) expression -> . expression compare expression
    (32) expression -> . expression arithop expression
    (33) expression -> . IDENTIFIER
    (34) expression -> . MINUS expression
    (35) expression -> . NUMBER

    IDENTIFIER      shift and go to state 41
    MINUS           shift and go to state 32
    NUMBER          shift and go to state 29

    expression                     shift and go to state 69

state 52

    (31) expression -> expression compare . expression
    (30) expression -> . IDENTIFIER LPAREN arglist RPAREN
    (31) expression -> . expression compare expression
    (32) expression -> . expression arithop expression
    (33) expression -> . IDENTIFIER
    (34) expression -> . MINUS expression
    (35) expression -> . NUMBER

    IDENTIFIER      shift and go to state 41
    MINUS           shift and go to state 32
    NUMBER          shift and go to state 29

    expression                     shift and go to state 70

state 53

    (42) arithop -> DIVIDE .

    IDENTIFIER      reduce using rule 42 (arithop -> DIVIDE .)
    MINUS           reduce using rule 42 (arithop -> DIVIDE .)
    NUMBER          reduce using rule 42 (arithop -> DIVIDE .)


state 54

    (23) statement -> expression SEMICOLON .

    RETURN          reduce using rule 23 (statement -> expression SEMICOLON .)
    LOOP            reduce using rule 23 (statement -> expression SEMICOLON .)
    BREAK           reduce using rule 23 (statement -> expression SEMICOLON .)
    WHILE           reduce using rule 23 (statement -> expression SEMICOLON .)
    IDENTIFIER      reduce using rule 23 (statement -> expression SEMICOLON .)
    MINUS           reduce using rule 23 (statement -> expression SEMICOLON .)
    NUMBER          reduce using rule 23 (statement -> expression SEMICOLON .)
    IF              reduce using rule 23 (statement -> expression SEMICOLON .)
    RBRACE          reduce using rule 23 (statement -> expression SEMICOLON .)


state 55

    (41) arithop -> TIMES .

    IDENTIFIER      reduce using rule 41 (arithop -> TIMES .)
    MINUS           reduce using rule 41 (arithop -> TIMES .)
    NUMBER          reduce using rule 41 (arithop -> TIMES .)


state 56

    (37) compare -> LESSTHAN .

    IDENTIFIER      reduce using rule 37 (compare -> LESSTHAN .)
    MINUS           reduce using rule 37 (compare -> LESSTHAN .)
    NUMBER          reduce using rule 37 (compare -> LESSTHAN .)


state 57

    (39) arithop -> PLUS .

    IDENTIFIER      reduce using rule 39 (arithop -> PLUS .)
    MINUS           reduce using rule 39 (arithop -> PLUS .)
    NUMBER          reduce using rule 39 (arithop -> PLUS .)


state 58

    (36) compare -> ISEQUAL .

    IDENTIFIER      reduce using rule 36 (compare -> ISEQUAL .)
    MINUS           reduce using rule 36 (compare -> ISEQUAL .)
    NUMBER          reduce using rule 36 (compare -> ISEQUAL .)


state 59

    (38) compare -> MORETHAN .

    IDENTIFIER      reduce using rule 38 (compare -> MORETHAN .)
    MINUS           reduce using rule 38 (compare -> MORETHAN .)
    NUMBER          reduce using rule 38 (compare -> MORETHAN .)


state 60

    (40) arithop -> MINUS .

    IDENTIFIER      reduce using rule 40 (arithop -> MINUS .)
    MINUS           reduce using rule 40 (arithop -> MINUS .)
    NUMBER          reduce using rule 40 (arithop -> MINUS .)


state 61

    (26) statement -> LOOP LBRACE . statementlist RBRACE
    (21) statementlist -> . empty
    (22) statementlist -> . statement statementlist
    (16) empty -> .
    (23) statement -> . expression SEMICOLON
    (24) statement -> . ifelse
    (25) statement -> . RETURN expression SEMICOLON
    (26) statement -> . LOOP LBRACE statementlist RBRACE
    (27) statement -> . BREAK SEMICOLON
    (28) statement -> . WHILE LPAREN expression RPAREN LBRACE statementlist RBRACE
    (29) statement -> . IDENTIFIER ASSIGN expression SEMICOLON
    (30) expression -> . IDENTIFIER LPAREN arglist RPAREN
    (31) expression -> . expression compare expression
    (32) expression -> . expression arithop expression
    (33) expression -> . IDENTIFIER
    (34) expression -> . MINUS expression
    (35) expression -> . NUMBER
    (47) ifelse -> . IF LPAREN expression RPAREN LBRACE statementlist RBRACE elifgroup optelse

    RBRACE          reduce using rule 16 (empty -> .)
    RETURN          shift and go to state 28
    LOOP            shift and go to state 40
    BREAK           shift and go to state 38
    WHILE           shift and go to state 31
    IDENTIFIER      shift and go to state 35
    MINUS           shift and go to state 32
    NUMBER          shift and go to state 29
    IF              shift and go to state 37

    statementlist                  shift and go to state 71
    ifelse                         shift and go to state 33
    statement                      shift and go to state 34
    expression                     shift and go to state 39
    empty                          shift and go to state 36

state 62

    (25) statement -> RETURN expression SEMICOLON .

    RETURN          reduce using rule 25 (statement -> RETURN expression SEMICOLON .)
    LOOP            reduce using rule 25 (statement -> RETURN expression SEMICOLON .)
    BREAK           reduce using rule 25 (statement -> RETURN expression SEMICOLON .)
    WHILE           reduce using rule 25 (statement -> RETURN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 25 (statement -> RETURN expression SEMICOLON .)
    MINUS           reduce using rule 25 (statement -> RETURN expression SEMICOLON .)
    NUMBER          reduce using rule 25 (statement -> RETURN expression SEMICOLON .)
    IF              reduce using rule 25 (statement -> RETURN expression SEMICOLON .)
    RBRACE          reduce using rule 25 (statement -> RETURN expression SEMICOLON .)


state 63

    (28) statement -> WHILE LPAREN expression . RPAREN LBRACE statementlist RBRACE
    (31) expression -> expression . compare expression
    (32) expression -> expression . arithop expression
    (36) compare -> . ISEQUAL
    (37) compare -> . LESSTHAN
    (38) compare -> . MORETHAN
    (39) arithop -> . PLUS
    (40) arithop -> . MINUS
    (41) arithop -> . TIMES
    (42) arithop -> . DIVIDE

    RPAREN          shift and go to state 72
    ISEQUAL         shift and go to state 58
    LESSTHAN        shift and go to state 56
    MORETHAN        shift and go to state 59
    PLUS            shift and go to state 57
    MINUS           shift and go to state 60
    TIMES           shift and go to state 55
    DIVIDE          shift and go to state 53

    arithop                        shift and go to state 51
    compare                        shift and go to state 52

state 64

    (30) expression -> IDENTIFIER LPAREN arglist . RPAREN

    RPAREN          shift and go to state 73


state 65

    (18) arglist -> expression .
    (19) arglist -> expression . COMMA arglist
    (31) expression -> expression . compare expression
    (32) expression -> expression . arithop expression
    (36) compare -> . ISEQUAL
    (37) compare -> . LESSTHAN
    (38) compare -> . MORETHAN
    (39) arithop -> . PLUS
    (40) arithop -> . MINUS
    (41) arithop -> . TIMES
    (42) arithop -> . DIVIDE

    RPAREN          reduce using rule 18 (arglist -> expression .)
    COMMA           shift and go to state 74
    ISEQUAL         shift and go to state 58
    LESSTHAN        shift and go to state 56
    MORETHAN        shift and go to state 59
    PLUS            shift and go to state 57
    MINUS           shift and go to state 60
    TIMES           shift and go to state 55
    DIVIDE          shift and go to state 53

    arithop                        shift and go to state 51
    compare                        shift and go to state 52

state 66

    (17) arglist -> empty .

    RPAREN          reduce using rule 17 (arglist -> empty .)


state 67

    (29) statement -> IDENTIFIER ASSIGN expression . SEMICOLON
    (31) expression -> expression . compare expression
    (32) expression -> expression . arithop expression
    (36) compare -> . ISEQUAL
    (37) compare -> . LESSTHAN
    (38) compare -> . MORETHAN
    (39) arithop -> . PLUS
    (40) arithop -> . MINUS
    (41) arithop -> . TIMES
    (42) arithop -> . DIVIDE

    SEMICOLON       shift and go to state 75
    ISEQUAL         shift and go to state 58
    LESSTHAN        shift and go to state 56
    MORETHAN        shift and go to state 59
    PLUS            shift and go to state 57
    MINUS           shift and go to state 60
    TIMES           shift and go to state 55
    DIVIDE          shift and go to state 53

    arithop                        shift and go to state 51
    compare                        shift and go to state 52

state 68

    (47) ifelse -> IF LPAREN expression . RPAREN LBRACE statementlist RBRACE elifgroup optelse
    (31) expression -> expression . compare expression
    (32) expression -> expression . arithop expression
    (36) compare -> . ISEQUAL
    (37) compare -> . LESSTHAN
    (38) compare -> . MORETHAN
    (39) arithop -> . PLUS
    (40) arithop -> . MINUS
    (41) arithop -> . TIMES
    (42) arithop -> . DIVIDE

    RPAREN          shift and go to state 76
    ISEQUAL         shift and go to state 58
    LESSTHAN        shift and go to state 56
    MORETHAN        shift and go to state 59
    PLUS            shift and go to state 57
    MINUS           shift and go to state 60
    TIMES           shift and go to state 55
    DIVIDE          shift and go to state 53

    arithop                        shift and go to state 51
    compare                        shift and go to state 52

state 69

    (32) expression -> expression arithop expression .
    (31) expression -> expression . compare expression
    (32) expression -> expression . arithop expression
    (36) compare -> . ISEQUAL
    (37) compare -> . LESSTHAN
    (38) compare -> . MORETHAN
    (39) arithop -> . PLUS
    (40) arithop -> . MINUS
    (41) arithop -> . TIMES
    (42) arithop -> . DIVIDE

  ! shift/reduce conflict for ISEQUAL resolved as shift
  ! shift/reduce conflict for LESSTHAN resolved as shift
  ! shift/reduce conflict for MORETHAN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
    SEMICOLON       reduce using rule 32 (expression -> expression arithop expression .)
    RPAREN          reduce using rule 32 (expression -> expression arithop expression .)
    COMMA           reduce using rule 32 (expression -> expression arithop expression .)
    ISEQUAL         shift and go to state 58
    LESSTHAN        shift and go to state 56
    MORETHAN        shift and go to state 59
    PLUS            shift and go to state 57
    MINUS           shift and go to state 60
    TIMES           shift and go to state 55
    DIVIDE          shift and go to state 53

  ! ISEQUAL         [ reduce using rule 32 (expression -> expression arithop expression .) ]
  ! LESSTHAN        [ reduce using rule 32 (expression -> expression arithop expression .) ]
  ! MORETHAN        [ reduce using rule 32 (expression -> expression arithop expression .) ]
  ! PLUS            [ reduce using rule 32 (expression -> expression arithop expression .) ]
  ! MINUS           [ reduce using rule 32 (expression -> expression arithop expression .) ]
  ! TIMES           [ reduce using rule 32 (expression -> expression arithop expression .) ]
  ! DIVIDE          [ reduce using rule 32 (expression -> expression arithop expression .) ]

    arithop                        shift and go to state 51
    compare                        shift and go to state 52

state 70

    (31) expression -> expression compare expression .
    (31) expression -> expression . compare expression
    (32) expression -> expression . arithop expression
    (36) compare -> . ISEQUAL
    (37) compare -> . LESSTHAN
    (38) compare -> . MORETHAN
    (39) arithop -> . PLUS
    (40) arithop -> . MINUS
    (41) arithop -> . TIMES
    (42) arithop -> . DIVIDE

  ! shift/reduce conflict for ISEQUAL resolved as shift
  ! shift/reduce conflict for LESSTHAN resolved as shift
  ! shift/reduce conflict for MORETHAN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
    SEMICOLON       reduce using rule 31 (expression -> expression compare expression .)
    RPAREN          reduce using rule 31 (expression -> expression compare expression .)
    COMMA           reduce using rule 31 (expression -> expression compare expression .)
    ISEQUAL         shift and go to state 58
    LESSTHAN        shift and go to state 56
    MORETHAN        shift and go to state 59
    PLUS            shift and go to state 57
    MINUS           shift and go to state 60
    TIMES           shift and go to state 55
    DIVIDE          shift and go to state 53

  ! ISEQUAL         [ reduce using rule 31 (expression -> expression compare expression .) ]
  ! LESSTHAN        [ reduce using rule 31 (expression -> expression compare expression .) ]
  ! MORETHAN        [ reduce using rule 31 (expression -> expression compare expression .) ]
  ! PLUS            [ reduce using rule 31 (expression -> expression compare expression .) ]
  ! MINUS           [ reduce using rule 31 (expression -> expression compare expression .) ]
  ! TIMES           [ reduce using rule 31 (expression -> expression compare expression .) ]
  ! DIVIDE          [ reduce using rule 31 (expression -> expression compare expression .) ]

    arithop                        shift and go to state 51
    compare                        shift and go to state 52

state 71

    (26) statement -> LOOP LBRACE statementlist . RBRACE

    RBRACE          shift and go to state 77


state 72

    (28) statement -> WHILE LPAREN expression RPAREN . LBRACE statementlist RBRACE

    LBRACE          shift and go to state 78


state 73

    (30) expression -> IDENTIFIER LPAREN arglist RPAREN .

    SEMICOLON       reduce using rule 30 (expression -> IDENTIFIER LPAREN arglist RPAREN .)
    ISEQUAL         reduce using rule 30 (expression -> IDENTIFIER LPAREN arglist RPAREN .)
    LESSTHAN        reduce using rule 30 (expression -> IDENTIFIER LPAREN arglist RPAREN .)
    MORETHAN        reduce using rule 30 (expression -> IDENTIFIER LPAREN arglist RPAREN .)
    PLUS            reduce using rule 30 (expression -> IDENTIFIER LPAREN arglist RPAREN .)
    MINUS           reduce using rule 30 (expression -> IDENTIFIER LPAREN arglist RPAREN .)
    TIMES           reduce using rule 30 (expression -> IDENTIFIER LPAREN arglist RPAREN .)
    DIVIDE          reduce using rule 30 (expression -> IDENTIFIER LPAREN arglist RPAREN .)
    RPAREN          reduce using rule 30 (expression -> IDENTIFIER LPAREN arglist RPAREN .)
    COMMA           reduce using rule 30 (expression -> IDENTIFIER LPAREN arglist RPAREN .)


state 74

    (19) arglist -> expression COMMA . arglist
    (17) arglist -> . empty
    (18) arglist -> . expression
    (19) arglist -> . expression COMMA arglist
    (16) empty -> .
    (30) expression -> . IDENTIFIER LPAREN arglist RPAREN
    (31) expression -> . expression compare expression
    (32) expression -> . expression arithop expression
    (33) expression -> . IDENTIFIER
    (34) expression -> . MINUS expression
    (35) expression -> . NUMBER

    RPAREN          reduce using rule 16 (empty -> .)
    IDENTIFIER      shift and go to state 41
    MINUS           shift and go to state 32
    NUMBER          shift and go to state 29

    arglist                        shift and go to state 79
    expression                     shift and go to state 65
    empty                          shift and go to state 66

state 75

    (29) statement -> IDENTIFIER ASSIGN expression SEMICOLON .

    RETURN          reduce using rule 29 (statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    LOOP            reduce using rule 29 (statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    BREAK           reduce using rule 29 (statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 29 (statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 29 (statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    MINUS           reduce using rule 29 (statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    NUMBER          reduce using rule 29 (statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 29 (statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 29 (statement -> IDENTIFIER ASSIGN expression SEMICOLON .)


state 76

    (47) ifelse -> IF LPAREN expression RPAREN . LBRACE statementlist RBRACE elifgroup optelse

    LBRACE          shift and go to state 80


state 77

    (26) statement -> LOOP LBRACE statementlist RBRACE .

    RETURN          reduce using rule 26 (statement -> LOOP LBRACE statementlist RBRACE .)
    LOOP            reduce using rule 26 (statement -> LOOP LBRACE statementlist RBRACE .)
    BREAK           reduce using rule 26 (statement -> LOOP LBRACE statementlist RBRACE .)
    WHILE           reduce using rule 26 (statement -> LOOP LBRACE statementlist RBRACE .)
    IDENTIFIER      reduce using rule 26 (statement -> LOOP LBRACE statementlist RBRACE .)
    MINUS           reduce using rule 26 (statement -> LOOP LBRACE statementlist RBRACE .)
    NUMBER          reduce using rule 26 (statement -> LOOP LBRACE statementlist RBRACE .)
    IF              reduce using rule 26 (statement -> LOOP LBRACE statementlist RBRACE .)
    RBRACE          reduce using rule 26 (statement -> LOOP LBRACE statementlist RBRACE .)


state 78

    (28) statement -> WHILE LPAREN expression RPAREN LBRACE . statementlist RBRACE
    (21) statementlist -> . empty
    (22) statementlist -> . statement statementlist
    (16) empty -> .
    (23) statement -> . expression SEMICOLON
    (24) statement -> . ifelse
    (25) statement -> . RETURN expression SEMICOLON
    (26) statement -> . LOOP LBRACE statementlist RBRACE
    (27) statement -> . BREAK SEMICOLON
    (28) statement -> . WHILE LPAREN expression RPAREN LBRACE statementlist RBRACE
    (29) statement -> . IDENTIFIER ASSIGN expression SEMICOLON
    (30) expression -> . IDENTIFIER LPAREN arglist RPAREN
    (31) expression -> . expression compare expression
    (32) expression -> . expression arithop expression
    (33) expression -> . IDENTIFIER
    (34) expression -> . MINUS expression
    (35) expression -> . NUMBER
    (47) ifelse -> . IF LPAREN expression RPAREN LBRACE statementlist RBRACE elifgroup optelse

    RBRACE          reduce using rule 16 (empty -> .)
    RETURN          shift and go to state 28
    LOOP            shift and go to state 40
    BREAK           shift and go to state 38
    WHILE           shift and go to state 31
    IDENTIFIER      shift and go to state 35
    MINUS           shift and go to state 32
    NUMBER          shift and go to state 29
    IF              shift and go to state 37

    statementlist                  shift and go to state 81
    ifelse                         shift and go to state 33
    statement                      shift and go to state 34
    expression                     shift and go to state 39
    empty                          shift and go to state 36

state 79

    (19) arglist -> expression COMMA arglist .

    RPAREN          reduce using rule 19 (arglist -> expression COMMA arglist .)


state 80

    (47) ifelse -> IF LPAREN expression RPAREN LBRACE . statementlist RBRACE elifgroup optelse
    (21) statementlist -> . empty
    (22) statementlist -> . statement statementlist
    (16) empty -> .
    (23) statement -> . expression SEMICOLON
    (24) statement -> . ifelse
    (25) statement -> . RETURN expression SEMICOLON
    (26) statement -> . LOOP LBRACE statementlist RBRACE
    (27) statement -> . BREAK SEMICOLON
    (28) statement -> . WHILE LPAREN expression RPAREN LBRACE statementlist RBRACE
    (29) statement -> . IDENTIFIER ASSIGN expression SEMICOLON
    (30) expression -> . IDENTIFIER LPAREN arglist RPAREN
    (31) expression -> . expression compare expression
    (32) expression -> . expression arithop expression
    (33) expression -> . IDENTIFIER
    (34) expression -> . MINUS expression
    (35) expression -> . NUMBER
    (47) ifelse -> . IF LPAREN expression RPAREN LBRACE statementlist RBRACE elifgroup optelse

    RBRACE          reduce using rule 16 (empty -> .)
    RETURN          shift and go to state 28
    LOOP            shift and go to state 40
    BREAK           shift and go to state 38
    WHILE           shift and go to state 31
    IDENTIFIER      shift and go to state 35
    MINUS           shift and go to state 32
    NUMBER          shift and go to state 29
    IF              shift and go to state 37

    statementlist                  shift and go to state 82
    ifelse                         shift and go to state 33
    statement                      shift and go to state 34
    expression                     shift and go to state 39
    empty                          shift and go to state 36

state 81

    (28) statement -> WHILE LPAREN expression RPAREN LBRACE statementlist . RBRACE

    RBRACE          shift and go to state 83


state 82

    (47) ifelse -> IF LPAREN expression RPAREN LBRACE statementlist . RBRACE elifgroup optelse

    RBRACE          shift and go to state 84


state 83

    (28) statement -> WHILE LPAREN expression RPAREN LBRACE statementlist RBRACE .

    RETURN          reduce using rule 28 (statement -> WHILE LPAREN expression RPAREN LBRACE statementlist RBRACE .)
    LOOP            reduce using rule 28 (statement -> WHILE LPAREN expression RPAREN LBRACE statementlist RBRACE .)
    BREAK           reduce using rule 28 (statement -> WHILE LPAREN expression RPAREN LBRACE statementlist RBRACE .)
    WHILE           reduce using rule 28 (statement -> WHILE LPAREN expression RPAREN LBRACE statementlist RBRACE .)
    IDENTIFIER      reduce using rule 28 (statement -> WHILE LPAREN expression RPAREN LBRACE statementlist RBRACE .)
    MINUS           reduce using rule 28 (statement -> WHILE LPAREN expression RPAREN LBRACE statementlist RBRACE .)
    NUMBER          reduce using rule 28 (statement -> WHILE LPAREN expression RPAREN LBRACE statementlist RBRACE .)
    IF              reduce using rule 28 (statement -> WHILE LPAREN expression RPAREN LBRACE statementlist RBRACE .)
    RBRACE          reduce using rule 28 (statement -> WHILE LPAREN expression RPAREN LBRACE statementlist RBRACE .)


state 84

    (47) ifelse -> IF LPAREN expression RPAREN LBRACE statementlist RBRACE . elifgroup optelse
    (43) elifgroup -> . empty
    (44) elifgroup -> . ELIF LPAREN expression RPAREN LBRACE statementlist RBRACE elifgroup
    (16) empty -> .

    ELIF            shift and go to state 85
    ELSE            reduce using rule 16 (empty -> .)
    RETURN          reduce using rule 16 (empty -> .)
    LOOP            reduce using rule 16 (empty -> .)
    BREAK           reduce using rule 16 (empty -> .)
    WHILE           reduce using rule 16 (empty -> .)
    IDENTIFIER      reduce using rule 16 (empty -> .)
    MINUS           reduce using rule 16 (empty -> .)
    NUMBER          reduce using rule 16 (empty -> .)
    IF              reduce using rule 16 (empty -> .)
    RBRACE          reduce using rule 16 (empty -> .)

    empty                          shift and go to state 86
    elifgroup                      shift and go to state 87

state 85

    (44) elifgroup -> ELIF . LPAREN expression RPAREN LBRACE statementlist RBRACE elifgroup

    LPAREN          shift and go to state 88


state 86

    (43) elifgroup -> empty .

    ELSE            reduce using rule 43 (elifgroup -> empty .)
    RETURN          reduce using rule 43 (elifgroup -> empty .)
    LOOP            reduce using rule 43 (elifgroup -> empty .)
    BREAK           reduce using rule 43 (elifgroup -> empty .)
    WHILE           reduce using rule 43 (elifgroup -> empty .)
    IDENTIFIER      reduce using rule 43 (elifgroup -> empty .)
    MINUS           reduce using rule 43 (elifgroup -> empty .)
    NUMBER          reduce using rule 43 (elifgroup -> empty .)
    IF              reduce using rule 43 (elifgroup -> empty .)
    RBRACE          reduce using rule 43 (elifgroup -> empty .)


state 87

    (47) ifelse -> IF LPAREN expression RPAREN LBRACE statementlist RBRACE elifgroup . optelse
    (45) optelse -> . empty
    (46) optelse -> . ELSE LBRACE statementlist RBRACE
    (16) empty -> .

    ELSE            shift and go to state 89
    RETURN          reduce using rule 16 (empty -> .)
    LOOP            reduce using rule 16 (empty -> .)
    BREAK           reduce using rule 16 (empty -> .)
    WHILE           reduce using rule 16 (empty -> .)
    IDENTIFIER      reduce using rule 16 (empty -> .)
    MINUS           reduce using rule 16 (empty -> .)
    NUMBER          reduce using rule 16 (empty -> .)
    IF              reduce using rule 16 (empty -> .)
    RBRACE          reduce using rule 16 (empty -> .)

    empty                          shift and go to state 91
    optelse                        shift and go to state 90

state 88

    (44) elifgroup -> ELIF LPAREN . expression RPAREN LBRACE statementlist RBRACE elifgroup
    (30) expression -> . IDENTIFIER LPAREN arglist RPAREN
    (31) expression -> . expression compare expression
    (32) expression -> . expression arithop expression
    (33) expression -> . IDENTIFIER
    (34) expression -> . MINUS expression
    (35) expression -> . NUMBER

    IDENTIFIER      shift and go to state 41
    MINUS           shift and go to state 32
    NUMBER          shift and go to state 29

    expression                     shift and go to state 92

state 89

    (46) optelse -> ELSE . LBRACE statementlist RBRACE

    LBRACE          shift and go to state 93


state 90

    (47) ifelse -> IF LPAREN expression RPAREN LBRACE statementlist RBRACE elifgroup optelse .

    RETURN          reduce using rule 47 (ifelse -> IF LPAREN expression RPAREN LBRACE statementlist RBRACE elifgroup optelse .)
    LOOP            reduce using rule 47 (ifelse -> IF LPAREN expression RPAREN LBRACE statementlist RBRACE elifgroup optelse .)
    BREAK           reduce using rule 47 (ifelse -> IF LPAREN expression RPAREN LBRACE statementlist RBRACE elifgroup optelse .)
    WHILE           reduce using rule 47 (ifelse -> IF LPAREN expression RPAREN LBRACE statementlist RBRACE elifgroup optelse .)
    IDENTIFIER      reduce using rule 47 (ifelse -> IF LPAREN expression RPAREN LBRACE statementlist RBRACE elifgroup optelse .)
    MINUS           reduce using rule 47 (ifelse -> IF LPAREN expression RPAREN LBRACE statementlist RBRACE elifgroup optelse .)
    NUMBER          reduce using rule 47 (ifelse -> IF LPAREN expression RPAREN LBRACE statementlist RBRACE elifgroup optelse .)
    IF              reduce using rule 47 (ifelse -> IF LPAREN expression RPAREN LBRACE statementlist RBRACE elifgroup optelse .)
    RBRACE          reduce using rule 47 (ifelse -> IF LPAREN expression RPAREN LBRACE statementlist RBRACE elifgroup optelse .)


state 91

    (45) optelse -> empty .

    RETURN          reduce using rule 45 (optelse -> empty .)
    LOOP            reduce using rule 45 (optelse -> empty .)
    BREAK           reduce using rule 45 (optelse -> empty .)
    WHILE           reduce using rule 45 (optelse -> empty .)
    IDENTIFIER      reduce using rule 45 (optelse -> empty .)
    MINUS           reduce using rule 45 (optelse -> empty .)
    NUMBER          reduce using rule 45 (optelse -> empty .)
    IF              reduce using rule 45 (optelse -> empty .)
    RBRACE          reduce using rule 45 (optelse -> empty .)


state 92

    (44) elifgroup -> ELIF LPAREN expression . RPAREN LBRACE statementlist RBRACE elifgroup
    (31) expression -> expression . compare expression
    (32) expression -> expression . arithop expression
    (36) compare -> . ISEQUAL
    (37) compare -> . LESSTHAN
    (38) compare -> . MORETHAN
    (39) arithop -> . PLUS
    (40) arithop -> . MINUS
    (41) arithop -> . TIMES
    (42) arithop -> . DIVIDE

    RPAREN          shift and go to state 94
    ISEQUAL         shift and go to state 58
    LESSTHAN        shift and go to state 56
    MORETHAN        shift and go to state 59
    PLUS            shift and go to state 57
    MINUS           shift and go to state 60
    TIMES           shift and go to state 55
    DIVIDE          shift and go to state 53

    arithop                        shift and go to state 51
    compare                        shift and go to state 52

state 93

    (46) optelse -> ELSE LBRACE . statementlist RBRACE
    (21) statementlist -> . empty
    (22) statementlist -> . statement statementlist
    (16) empty -> .
    (23) statement -> . expression SEMICOLON
    (24) statement -> . ifelse
    (25) statement -> . RETURN expression SEMICOLON
    (26) statement -> . LOOP LBRACE statementlist RBRACE
    (27) statement -> . BREAK SEMICOLON
    (28) statement -> . WHILE LPAREN expression RPAREN LBRACE statementlist RBRACE
    (29) statement -> . IDENTIFIER ASSIGN expression SEMICOLON
    (30) expression -> . IDENTIFIER LPAREN arglist RPAREN
    (31) expression -> . expression compare expression
    (32) expression -> . expression arithop expression
    (33) expression -> . IDENTIFIER
    (34) expression -> . MINUS expression
    (35) expression -> . NUMBER
    (47) ifelse -> . IF LPAREN expression RPAREN LBRACE statementlist RBRACE elifgroup optelse

    RBRACE          reduce using rule 16 (empty -> .)
    RETURN          shift and go to state 28
    LOOP            shift and go to state 40
    BREAK           shift and go to state 38
    WHILE           shift and go to state 31
    IDENTIFIER      shift and go to state 35
    MINUS           shift and go to state 32
    NUMBER          shift and go to state 29
    IF              shift and go to state 37

    statementlist                  shift and go to state 95
    ifelse                         shift and go to state 33
    statement                      shift and go to state 34
    expression                     shift and go to state 39
    empty                          shift and go to state 36

state 94

    (44) elifgroup -> ELIF LPAREN expression RPAREN . LBRACE statementlist RBRACE elifgroup

    LBRACE          shift and go to state 96


state 95

    (46) optelse -> ELSE LBRACE statementlist . RBRACE

    RBRACE          shift and go to state 97


state 96

    (44) elifgroup -> ELIF LPAREN expression RPAREN LBRACE . statementlist RBRACE elifgroup
    (21) statementlist -> . empty
    (22) statementlist -> . statement statementlist
    (16) empty -> .
    (23) statement -> . expression SEMICOLON
    (24) statement -> . ifelse
    (25) statement -> . RETURN expression SEMICOLON
    (26) statement -> . LOOP LBRACE statementlist RBRACE
    (27) statement -> . BREAK SEMICOLON
    (28) statement -> . WHILE LPAREN expression RPAREN LBRACE statementlist RBRACE
    (29) statement -> . IDENTIFIER ASSIGN expression SEMICOLON
    (30) expression -> . IDENTIFIER LPAREN arglist RPAREN
    (31) expression -> . expression compare expression
    (32) expression -> . expression arithop expression
    (33) expression -> . IDENTIFIER
    (34) expression -> . MINUS expression
    (35) expression -> . NUMBER
    (47) ifelse -> . IF LPAREN expression RPAREN LBRACE statementlist RBRACE elifgroup optelse

    RBRACE          reduce using rule 16 (empty -> .)
    RETURN          shift and go to state 28
    LOOP            shift and go to state 40
    BREAK           shift and go to state 38
    WHILE           shift and go to state 31
    IDENTIFIER      shift and go to state 35
    MINUS           shift and go to state 32
    NUMBER          shift and go to state 29
    IF              shift and go to state 37

    statementlist                  shift and go to state 98
    ifelse                         shift and go to state 33
    statement                      shift and go to state 34
    expression                     shift and go to state 39
    empty                          shift and go to state 36

state 97

    (46) optelse -> ELSE LBRACE statementlist RBRACE .

    RETURN          reduce using rule 46 (optelse -> ELSE LBRACE statementlist RBRACE .)
    LOOP            reduce using rule 46 (optelse -> ELSE LBRACE statementlist RBRACE .)
    BREAK           reduce using rule 46 (optelse -> ELSE LBRACE statementlist RBRACE .)
    WHILE           reduce using rule 46 (optelse -> ELSE LBRACE statementlist RBRACE .)
    IDENTIFIER      reduce using rule 46 (optelse -> ELSE LBRACE statementlist RBRACE .)
    MINUS           reduce using rule 46 (optelse -> ELSE LBRACE statementlist RBRACE .)
    NUMBER          reduce using rule 46 (optelse -> ELSE LBRACE statementlist RBRACE .)
    IF              reduce using rule 46 (optelse -> ELSE LBRACE statementlist RBRACE .)
    RBRACE          reduce using rule 46 (optelse -> ELSE LBRACE statementlist RBRACE .)


state 98

    (44) elifgroup -> ELIF LPAREN expression RPAREN LBRACE statementlist . RBRACE elifgroup

    RBRACE          shift and go to state 99


state 99

    (44) elifgroup -> ELIF LPAREN expression RPAREN LBRACE statementlist RBRACE . elifgroup
    (43) elifgroup -> . empty
    (44) elifgroup -> . ELIF LPAREN expression RPAREN LBRACE statementlist RBRACE elifgroup
    (16) empty -> .

    ELIF            shift and go to state 85
    ELSE            reduce using rule 16 (empty -> .)
    RETURN          reduce using rule 16 (empty -> .)
    LOOP            reduce using rule 16 (empty -> .)
    BREAK           reduce using rule 16 (empty -> .)
    WHILE           reduce using rule 16 (empty -> .)
    IDENTIFIER      reduce using rule 16 (empty -> .)
    MINUS           reduce using rule 16 (empty -> .)
    NUMBER          reduce using rule 16 (empty -> .)
    IF              reduce using rule 16 (empty -> .)
    RBRACE          reduce using rule 16 (empty -> .)

    empty                          shift and go to state 86
    elifgroup                      shift and go to state 100

state 100

    (44) elifgroup -> ELIF LPAREN expression RPAREN LBRACE statementlist RBRACE elifgroup .

    ELSE            reduce using rule 44 (elifgroup -> ELIF LPAREN expression RPAREN LBRACE statementlist RBRACE elifgroup .)
    RETURN          reduce using rule 44 (elifgroup -> ELIF LPAREN expression RPAREN LBRACE statementlist RBRACE elifgroup .)
    LOOP            reduce using rule 44 (elifgroup -> ELIF LPAREN expression RPAREN LBRACE statementlist RBRACE elifgroup .)
    BREAK           reduce using rule 44 (elifgroup -> ELIF LPAREN expression RPAREN LBRACE statementlist RBRACE elifgroup .)
    WHILE           reduce using rule 44 (elifgroup -> ELIF LPAREN expression RPAREN LBRACE statementlist RBRACE elifgroup .)
    IDENTIFIER      reduce using rule 44 (elifgroup -> ELIF LPAREN expression RPAREN LBRACE statementlist RBRACE elifgroup .)
    MINUS           reduce using rule 44 (elifgroup -> ELIF LPAREN expression RPAREN LBRACE statementlist RBRACE elifgroup .)
    NUMBER          reduce using rule 44 (elifgroup -> ELIF LPAREN expression RPAREN LBRACE statementlist RBRACE elifgroup .)
    IF              reduce using rule 44 (elifgroup -> ELIF LPAREN expression RPAREN LBRACE statementlist RBRACE elifgroup .)
    RBRACE          reduce using rule 44 (elifgroup -> ELIF LPAREN expression RPAREN LBRACE statementlist RBRACE elifgroup .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ISEQUAL in state 45 resolved as shift
WARNING: shift/reduce conflict for LESSTHAN in state 45 resolved as shift
WARNING: shift/reduce conflict for MORETHAN in state 45 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 45 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 45 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 45 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 45 resolved as shift
WARNING: shift/reduce conflict for ISEQUAL in state 69 resolved as shift
WARNING: shift/reduce conflict for LESSTHAN in state 69 resolved as shift
WARNING: shift/reduce conflict for MORETHAN in state 69 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 69 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 69 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 69 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 69 resolved as shift
WARNING: shift/reduce conflict for ISEQUAL in state 70 resolved as shift
WARNING: shift/reduce conflict for LESSTHAN in state 70 resolved as shift
WARNING: shift/reduce conflict for MORETHAN in state 70 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 70 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 70 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 70 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 70 resolved as shift
