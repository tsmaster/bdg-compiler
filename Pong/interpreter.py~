


class VM:
    def __init__(stacksize = 1000, memsize=1000):
        self.stack=[]
        self.stacksize = stacksize
        self.memory=[0] * memsize
        self.allocated=[False] * memsize
        self.memsize = memsize
        
    def alloc(self, num_bytes):
        paddded_size = num_bytes + 1
        for i in range(self.memsize):
            found_blocker = False
            for j in range(padded_size):
                idx = i+j
                if idx >= memsize:
                    break
                if self.allocated[idx]:
                    found_blocker = True
                    break
            if not found_blocker:
                for j in range(padded_size):
                    self.allocated[i+j] = True
                return i+1
        return -1

def evaluate_opcodes(opcodes, stack=[]):
    for op in opcodes:
        op.eval(stack)
    return stack

def print_stack(stack):
    for o in stack:
        print o

def load_bytecode(fn):
    return open(fn,"rb").read()

class Opcode:
    def __str__(self):
        return "[-OP-]"

    def eval(self, stack):
        return 

class NumericLiteral(Opcode):
    def __init__(self, value):
        self.value = value

    def eval(self, stack):
        stack.append(self)

    def __str__(self):
        return "[%04d]" % self.value

class PlusOpcode(Opcode):
    def eval(self, stack):
        op1 = stack.pop().value
        op2 = stack.pop().value
        s = op1 + op2
        nl = NumericLiteral(s)
        stack.append(nl)

    def __str__(self):
        return "<SUM >"

class MinusOpcode(Opcode):
    def eval(self, stack):
        op1 = stack.pop().value
        op2 = stack.pop().value
        s = op1 - op2
        nl = NumericLiteral(s)
        stack.append(nl)

    def __str__(self):
        return "<DIFF>"

class MultiplyOpcode(Opcode):
    def eval(self, stack):
        op1 = stack.pop().value
        op2 = stack.pop().value
        s = op1 * op2
        nl = NumericLiteral(s)
        stack.append(nl)

    def __str__(self):
        return "<MULT>"

class IntegerDivideOpcode(Opcode):
    def eval(self, stack):
        op1 = stack.pop().value
        op2 = stack.pop().value
        s = op1 / op2
        nl = NumericLiteral(s)
        stack.append(nl)

    def __str__(self):
        return "<DIV >"

